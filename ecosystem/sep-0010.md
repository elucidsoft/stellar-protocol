## Preamble

```
SEP: 0010
Title: Stellar Web Authentication
Author: stellar.org
Status: Accepted
Created: 2018-07-31
Updated: 2018-07-31
Version 1.0.0
```

## Simple Summary

This SEP defines the standard way for clients such as wallets or exchanges to create authenticated web sessions on behalf of a user who holds a Stellar account. A wallet may want to authenticate with an anchor, for example, to upload KYC information in an authenticated way as described in [SEP-6](sep-0006.md).

## Abstract

The authentication flow is as follows:

1. The client visits the `/challenge` endpoint to request an invalid transaction to be signed
1. The client signs the transaction with their Stellar account's secret key
1. The client transmits the signed transaction back to the server via the `/jwt` endpoint
1. If the signature checks out, the server responds with a [JWT](jwt.io) that represents the user's session
1. Any future calls to the server can be authenticated by including the JWT as a parameter

The flow achieves several things:

* The client can verify that the server holds the secret key to a particular account
* The server can verify that the client holds the secret key to their account
* The client is able to prove their identity using a Ledger or other hardware wallet as well as by having direct access to the secret key
* The server can chose its own timeout for the user's session

## Transfer Server

This protocol requires the anchor or other party wishing to authenticate users implement endpoints on their `WEB_AUTH_SERVER`, specified in their [`stellar.toml`](sep-0001.md) file. This is how a wallet knows where to find the authorization server.

## API Endpoints

* [`GET /challenge`](#challenge): optional, but necessary for authentication (step 1)
* [`GET /jwt`](#jwt): optional, but necessary for authentication (step 2)

## Challenge

This endpoint must respond with a Stellar transaction signed by the server that has an invalid sequence number (0) and thus cannot be executed on the Stellar network. The client can then sign the transaction using standard Stellar libraries and submit it to `/jwt` to prove that they control their account. This approach is compatible with hardware wallets such as Ledger. The client can also verify the server's signature to be sure the challenge is signed by the `SIGNING_KEY` from the server's `stellar.toml`.

### Request

```
GET WEB_AUTH_SERVER/challenge
```

Request Parameters:

Name | Type | Description
-----|------|------------
`account` | `G...` string | The stellar account that the wallet wishes to authenticate with the server

Example:

```
GET https://api.example.com/challenge?account=GCIBUCGPOHWMMMFPFTDWBSVHQRT4DIBJ7AD6BZJYDITBK2LCVBYW7HUQ
```

### Response

On success the endpoint should return `200 OK` HTTP status code and a JSON object with a `transaction` field containing an XDR-encoded Stellar transaction with the following:

* source account set to server's account
* invalid sequence number (set to 0)
* time bounds: `{min: now(), max: now() + 300 }` (we recommend expiration of 5 minutes to give user time to sign transaction)
* operations: `manage_data(source: client_account, key: '<anchor name> auth', value: random_nonce())`
  * The value of key is not important, but can be the name of the anchor followed by `auth`. It can be at most 64 bytes.
  * The value must be a 64 byte long base64 encoded cryptographic-quality random string
* invalid sequence number (so the transaction cannot be run on the Stellar network)
* signature by the anchor

Example:
```
{
  "transaction": "AAAAAAVvtc2vNsygpxOUKCQKkmSJSQItaJ0LxMot3/9ups4/AAAAZAAAAAAAAAAAAAAAAQAAAABbV2YRAAAAAFtXZz0AAAAAAAAAAQAAAAEAAAAAoOOOGwQOwcfc0Wkr/b5MvcKvpqBuuP2CKfo1s/BCaN4AAAAKAAAAEGV4YW1wbGUuY29tIGF1dGgAAAABAAAAQEdaRUx1aU4zbHRjemdFR2xGU24yU2ZVVGFDVnkxMXM1aWNiMkxCSXc0dUZvd2lnQnliNFRUOFdoeklGdXdybmsAAAAAAAAAAW6mzj8AAABAXnnkROpP31vlXYpoa942wXIV7m9CrB3M+8TvJg5Fv+nVNEHABbwnxjKBnGidx2OmhhXLkyoYK0BPxe3RI7nbDQ=="
}
```

You can examine the example transaction in the [XDR Viewer](https://www.stellar.org/laboratory/#xdr-viewer?input=AAAAAAVvtc2vNsygpxOUKCQKkmSJSQItaJ0LxMot3%2F9ups4%2FAAAAZAAAAAAAAAAAAAAAAQAAAABbV2YRAAAAAFtXZz0AAAAAAAAAAQAAAAEAAAAAoOOOGwQOwcfc0Wkr%2Fb5MvcKvpqBuuP2CKfo1s%2FBCaN4AAAAKAAAAEGV4YW1wbGUuY29tIGF1dGgAAAABAAAAQEdaRUx1aU4zbHRjemdFR2xGU24yU2ZVVGFDVnkxMXM1aWNiMkxCSXc0dUZvd2lnQnliNFRUOFdoeklGdXdybmsAAAAAAAAAAW6mzj8AAABAXnnkROpP31vlXYpoa942wXIV7m9CrB3M%2B8TvJg5Fv%2BnVNEHABbwnxjKBnGidx2OmhhXLkyoYK0BPxe3RI7nbDQ%3D%3D&type=TransactionEnvelope).

Every other HTTP status code will be considered an error. For example:

```json
{
   "error": "The provided account has requested too many challenges recently. Try again later."
}
```

## JWT

This endpoint accepts a signed challenge transaction (that was previously returned by the `/challenge` endpoint). If the client's signature is valid, it responds with a [JSON Web Token](https://jwt.io/) authenticating the user. A server can pick its own expiration period for the token, however 24 hours is recommended.

### Request

```
GET WEB_AUTH_SERVER/jwt
```

Request Parameters:

Name | Type | Description
-----|------|------------
`transaction` | string | base64 encoded signed challenge transaction

Note that since `transaction` is base64 encoded.

Example:

```
GET https://api.example.com/jwt?transaction=AAAAAAVvtc2vNsygpxOUKCQKkmSJSQItaJ0LxMot3%2F9ups4%2FAAAAZAAAAAAAAAAAAAAAAQAAAABbV2YRAAAAAFtXZz0AAAAAAAAAAQAAAAEAAAAAoOOOGwQOwcfc0Wkr%2Fb5MvcKvpqBuuP2CKfo1s%2FBCaN4AAAAKAAAAEGV4YW1wbGUuY29tIGF1dGgAAAABAAAAQEdaRUx1aU4zbHRjemdFR2xGU24yU2ZVVGFDVnkxMXM1aWNiMkxCSXc0dUZvd2lnQnliNFRUOFdoeklGdXdybmsAAAAAAAAAAm6mzj8AAABAXnnkROpP31vlXYpoa942wXIV7m9CrB3M%2B8TvJg5Fv%2BnVNEHABbwnxjKBnGidx2OmhhXLkyoYK0BPxe3RI7nbDfBCaN4AAABAUXBXcDtzjrKjNcQ%2FMLYPTHkh6%2F5VXhMQ6LIbX2cpHwwNqi%2FugsnXLkVCcmSrhSaxZ1OZF38VVWObu%2BhDYj4SAw%3D%3D
```

### Response

If the anchor sees that the transaction meets the following conditions, it replies with a JWT authenticating the user.

* properly signed by anchor
* properly signed by user
* not expired (within time bounds)

On success the endpoint should return `200 OK` HTTP status code and a JSON object with the following fields:

Name | Type | Description
-----|------|------------
`jwt` | string | The JWT that a user can use to authenticate future endpoint calls with the anchor

Example:

```
{
  "jwt": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
}
```

Every other HTTP status code will be considered an error. For example:

```json
{
   "error": "The provided transaction is not valid"
}
```
